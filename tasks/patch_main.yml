# Pre Actions
- include: patch_tasks_pre.yml

- block:

  # If needs to perform patch actions
  - block:

    # Stop the database
    - include: run_sql.yml
      vars:
        sql_param : { file : "shutdown.sql" , folder : "patch_sql" , task_action : "Stop Database for OPatch" }
      when: not oci_mode or patch.dep_type is defined
      # When patch has a dependency, if the dependency is loaded running the full patch process instead of loading from lvm, the DB will be left online.

    ## APPLY ##

    - name: Run OPatch/opatch
      shell: |
          set -eo pipefail
          export ORACLE_HOME ORACLE_SID
          [ ! -d ~/opatch_logs ] && mkdir ~/opatch_logs
          ./opatch apply -silent {{ VM_folder }}/{{ patch.patch_number }} OPatch.SKIP_VERIFY_SPACE=true 2>&1 | tee ~/opatch_logs/{{ patch.patch_number }}.log
      environment:
        ORACLE_HOME: "{{ dbhome_locl }}"
        ORACLE_SID: "{{ mysid }}"
      args:
        chdir: "{{ dbhome_locl }}/OPatch"
      register: tmp_shell_output
      become: true
      become_user: oracle
      when: patch.apply_method is not defined or patch.apply_method == "opatch"
      delegate_to: "{{ vm_ip_address }}"

    # Put the value inside another variable to avoid it from getting replaced with "skip_reason": "Conditional result was False"
    - set_fact: shell_output="{{tmp_shell_output}}"
      when: tmp_shell_output is not skipped

    ## NAPPLY ##

    - name: Run OPatch/opatch NAPPLY
      shell: |
          set -eo pipefail
          export ORACLE_HOME ORACLE_SID
          [ ! -d ~/opatch_logs ] && mkdir ~/opatch_logs
          ./opatch napply -silent {{ VM_folder }}/{{ patch.patch_number }} OPatch.SKIP_VERIFY_SPACE=true 2>&1 | tee ~/opatch_logs/{{ patch.patch_number }}.log
      environment:
        ORACLE_HOME: "{{ dbhome_locl }}"
        ORACLE_SID: "{{ mysid }}"
      args:
        chdir: "{{ dbhome_locl }}/OPatch"
      register: tmp_shell_output
      become: true
      become_user: oracle
      when: patch.apply_method is defined and patch.apply_method == "napply"
      delegate_to: "{{ vm_ip_address }}"

    # Put the value inside another variable to avoid it from getting replaced with "skip_reason": "Conditional result was False"
    - set_fact: shell_output="{{tmp_shell_output}}"
      when: tmp_shell_output is not skipped

    ## OPATCHAUTO ##

    - name: Run OPatch/opatchauto
      shell: |
          set -eo pipefail
          export ORACLE_HOME ORACLE_SID
          ./opatchauto apply -binary {{ VM_folder }}/{{ patch.patch_number }} -oh $ORACLE_HOME -target_type oracle_database
      environment:
        ORACLE_HOME: "{{ dbhome_locl }}"
        ORACLE_SID: "{{ mysid }}"
      args:
        chdir: "{{ dbhome_locl }}/OPatch"
      register: tmp_shell_output
      become: true
      become_user: oracle
      when: patch.apply_method is defined and patch.apply_method == "opatchauto"
      delegate_to: "{{ vm_ip_address }}"

    # Put the value inside another variable to avoid it from getting replaced with "skip_reason": "Conditional result was False"
    - set_fact: shell_output="{{tmp_shell_output}}"
      when: tmp_shell_output is not skipped

    - name: Opatch Output
      debug: msg="{{ shell_output.stdout_lines }}"
      when: shell_output.stdout_lines is defined

    # Start the database
    - include: run_sql.yml
      vars:
        sql_param : { file : "startupCDB.sql" , folder : "patch_sql" , task_action : "Start Database for sqlpatch" }
      when: patch.type != "OJVM"

    # Start the database (in OJVM, it must be in upgrade mode)
    - include: run_sql.yml
      vars:
        sql_param : { file : "startupCDBOJVM.sql" , folder : "patch_sql" , task_action : "Start Database for OJVM sqlpatch" }
      when: patch.type == "OJVM"

    # Run Datapatch
    - name: Set datapatch try variable
      set_fact: datapatch_try=0

    - name: Run Datapatch
      include: datapatch.yml

    # Evaluate if it's needed to reexecute datapatch on 12.1.1 due to bug.

    # Bounce instance on OJVM to remove "upgrade" mode
    - block:

      - include: run_sql.yml
        vars:
          sql_param : { file : "shutdown.sql" , folder : "patch_sql" , task_action : "Stop Database" }

      - include: run_sql.yml
        vars:
          sql_param : { file : "startupCDB.sql" , folder : "patch_sql" , task_action : "Start Database" }

      when: patch.type == "OJVM"

    when: perform_patch_actions

  # Start the database
  - include: run_sql.yml
    vars:
      sql_param : { file : "startupCDB.sql" , folder : "patch_sql" , task_action : "Start Database for expdp" }
    when: not only_deploy_patch and not perform_patch_actions # We only start the DB if not started on prev the block and needed for the next.

  # When only_deploy_patch is false (most common case)
  - block:

    # User custom pre-scripts
    - include: run_script.yml
      loop: "{{ user_expdp_pre | flatten(levels=1) }}"
      loop_control:
        loop_var: script_param

    - name: Set version parameter for expdp
      set_fact:
        expdp_version: "version={{ target_db_version }}"
      when: (db_version.split('.')[0] | int) > target_db_version

    - name: Set compression parameter for expdp
      set_fact:
        expdp_compression: "compression=all compression_algorithm=high"
      when: patch.expdp_comp | default(true)

    - name: Export Database Tables
      shell: |
          {{ dbhome_locl }}/bin/expdp \
          userid={{ dump_user_int }}/{{ dump_pass }} \
          directory={{ dump_dir_name }} \
          {{ expdp_compression | default('') }} \
          metrics=yes \
          dumpfile={{ dump_file_prefix }}.dmp \
          logfile={{ dump_file_prefix }}.log \
          content=data_only \
          schemas={{ dump_user_int }} \
          {{ expdp_version | default('') }}
      environment:
        ORACLE_HOME: "{{ dbhome_locl }}"
        ORACLE_SID: "{{ mysid }}"
      become: true
      become_user: oracle
      delegate_to: "{{ vm_ip_address }}"

    # User custom post-scripts
    - include: run_script.yml
      loop: "{{ user_expdp_post | flatten(levels=1) }}"
      loop_control:
        loop_var: script_param

    when: not only_deploy_patch

  # Post Actions
  - include: patch_tasks_post.yml

  when: skip_all == false
# Skip all is true when dump file is already generated and skip_dump_exists is true at config.