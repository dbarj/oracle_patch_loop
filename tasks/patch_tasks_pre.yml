- name: "Processing {{ db_version }} {{ patch.type }} {{ patch.id }} - Patch {{ patch.patch_number }}"
  debug: msg="Processing {{ db_version }} {{ patch.type }} {{ patch.id }} - Patch {{ patch.patch_number }}"

- name : Define dump file name and parameters
  set_fact:
    dump_file_prefix: "tables_{{ db_version }}_{{ patch.base_ru | default('')}}{{ patch.type }}_{{ patch.id }}"
    skip_all: false
    fix_datapatch_retries: 0
    expdp_version: ""

# Ignore dumpfile checks when only_deploy_patch is true
- block:

  - name: "Check if {{ output_folder }}/expdp/{{ dump_file_prefix }}.dmp exists"
    stat:
      path: "{{ output_folder }}/expdp/{{ dump_file_prefix }}.dmp"
    register: dump_stat_result

  # Will skip all the rest if the dump file exists
  - name : Define skip_all
    set_fact:
      skip_all: "{{ dump_stat_result.stat.exists }}"
    when: skip_dump_exists

  - name : Remove dump file if exists
    file:
      state: absent
      path: "{{ shared_folder }}/{{ dump_file_prefix }}.dmp"
    when: not skip_all

  when: not only_deploy_patch

# Check if patch will need to reexecute datapatch
- name : Check datapatch reexecution
  set_fact:
    fix_datapatch_retries: "{{ err_list.retries }}"
  loop: "{{ list_retry_datapatch | flatten(levels=1) }}"
  loop_control:
    loop_var: err_list
  when:
    - err_list.version == db_version
    - err_list.type == patch.type
    - err_list.id == patch.id

# When not processing base release. i.e patch.patch_number != 0
- block:

  # Place patch file on the shared folder
  - name: Finding Patch File
    find:
      paths:     "{{ source_folder }}"
      patterns:  "p{{ patch.patch_number }}_{{ db_version | regex_replace('\\.','') }}0_Linux-x86-64.zip"
      recurse:   "yes"
      file_type: "file"
    register: find_result

  # Call downloader when download_patch is defined
  - block:

    - name: Call downloader
      include: download_patch.yml

    # Try again after downloader was called
    - name: Finding Patch File
      find:
        paths:     "{{ source_folder }}"
        patterns:  "p{{ patch.patch_number }}_{{ db_version | regex_replace('\\.','') }}0_Linux-x86-64.zip"
        recurse:   "yes"
        file_type: "file"
      register: find_result
    
    when: find_result.files[0] is undefined and download_patch

  # If still can't find the patch but ignore flag is set, jump to the next.
  - name : Patch is not there, but ignoring...
    set_fact:
      skip_all: true
    when: find_result.files[0] is undefined and error_on_no_patch == false

  - block:

    - fail:
        msg: "Could not find patch file. Check if patch folder is correct."
      when: find_result.files[0] is undefined

    - name: "Patch File"
      debug: msg="{{ find_result.files[0].path }}"

    - name : Define Patch file name
      set_fact:
        db_patch: "{{ find_result.files[0].path }}"
        unzip_patch_folder: "{{ shared_folder }}/{{ patch.patch_number }}"

    - name: Remove unzipped patch folder
      file:
        state: absent
        path: "{{ unzip_patch_folder }}"

    - name : Unzip Patch to VM shared folder
      unarchive:
        src: "{{ db_patch }}"
        dest: "{{ shared_folder }}"

    # When patch_folder variable is defined (mostly for BPs), extract that folder from unziped patch to apply
    - block:

      - name: Process only patch subfolder
        command: "mv {{ unzip_patch_folder }}/{{ patch.patch_folder }} {{ shared_folder }}"

      - name : Remove unzipped patch
        file:
          state: absent
          path: "{{ unzip_patch_folder }}"

      - name : Rename patch subfolder
        shell: "mv {{ shared_folder }}/{{ patch.patch_folder }} {{ unzip_patch_folder }}"

      when: patch.patch_folder is defined

    # This is required as skip_all may be set by error_on_no_patch == false
    when: not skip_all

  when: patch.patch_number != 0 and not skip_all

# Trigger database refresh command if it was already started
- block:

  - include: vbox_reload.yml
    when: not oci_mode

  - include: lvm_reload.yml
    when: oci_mode

  when: database_started and not skip_all

# Trigger database start command for the first time if never started
- block:

  - name: Call role to start OCI VM
    include_role:
      name: oci_compute_instance_actions
    vars:
      compute_action: start
    when: oci_mode

  - include: vbox_reload.yml
    when: not oci_mode

  - include: lvm_reload.yml
    when: oci_mode

  - include: setup_opatch.yml
  - include: setup_database.yml

  - name : Define database_started variable to true.
    set_fact:
      database_started: true

  when: not database_started and not skip_all

# Replace opatch with latest version, when not processing base release. i.e patch.patch_number != 0
- block:

  - name: Remove OPatch folder
    file:
      state: absent
      path: "{{ dbhome_locl }}/OPatch"
    become: true
    become_user: oracle
    delegate_to: "{{ vm_ip_address }}"

  - name : Unzip OPatch from VM shared folder
    unarchive:
      src: "{{ db_opatch }}"
      dest: "{{ dbhome_locl }}"
    become: true
    become_user: oracle
    delegate_to: "{{ vm_ip_address }}"
  
  # skip_all must come first as db_opatch may not yet be declared
  when: not skip_all and db_opatch|length > 0 and patch.patch_number != 0