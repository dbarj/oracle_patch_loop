# Pre Actions
- include: patch_tasks_pre.yml

- block:

  # If needs to perform patch actions
  - block:

    # Stop the database
    - include: run_sql.yml
      vars:
        sql_param : { file : "shutdown.sql" , folder : "patch_sql" , task_action : "Stop Database for OPatch" }
      when: not oci_mode or patch.dep_type is defined
      # When patch has a dependency, if the dependency is loaded running the full patch process instead of loading from lvm, the DB will be left online.

    ## APPLY ##

    - name: Run OPatch
      shell: |
          export ORACLE_HOME ORACLE_SID
          ./opatch apply -silent {{ VM_folder }}/{{ patch.patch_number }} -ocmrf {{ VM_folder }}/ocm.rsp
      environment:
        ORACLE_HOME: "{{ dbhome_locl }}"
        ORACLE_SID: "{{ mysid }}"
      args:
        chdir: "{{ dbhome_locl }}/OPatch"
      register: tmp_shell_output
      become: true
      become_user: oracle
      when: patch.apply_method is not defined or patch.apply_method == "opatch"
      delegate_to: "{{ vm_ip_address }}"

    # Put the value inside another variable to avoid it from getting replaced with "skip_reason": "Conditional result was False"
    - set_fact: shell_output="{{tmp_shell_output}}"
      when: tmp_shell_output is not skipped

    ## NAPPLY ##

    - name: Run OPatch/opatch NAPPLY
      shell: |
          export ORACLE_HOME ORACLE_SID
          ./opatch napply -silent {{ VM_folder }}/{{ patch.patch_number }} -ocmrf {{ VM_folder }}/ocm.rsp
      environment:
        ORACLE_HOME: "{{ dbhome_locl }}"
        ORACLE_SID: "{{ mysid }}"
      args:
        chdir: "{{ dbhome_locl }}/OPatch"
      register: tmp_shell_output
      become: true
      become_user: oracle
      when: patch.apply_method is defined and patch.apply_method == "napply"
      delegate_to: "{{ vm_ip_address }}"

    # Put the value inside another variable to avoid it from getting replaced with "skip_reason": "Conditional result was False"
    - set_fact: shell_output="{{tmp_shell_output}}"
      when: tmp_shell_output is not skipped

    - name: Opatch Output
      debug: msg="{{ shell_output.stdout_lines }}"
      when: shell_output.stdout_lines is defined

    - name: Disable Database Vault
      shell: |
           {{ dbhome_locl }}/bin/chopt disable dv
      environment:
        ORACLE_HOME: "{{ dbhome_locl }}"
        ORACLE_SID: "{{ mysid }}"
      become: true
      become_user: oracle
      delegate_to: "{{ vm_ip_address }}"
      when: dbvault_enabled
    
    # Start the database
    - include: run_sql.yml
      vars:
        sql_param : { file : "startup.sql" , folder : "patch_sql" , task_action : "Start Database for sqlpatch" }
    
    # Apply patch changes on DB (if PSU)
    - include: run_sql.yml
      vars:
        sql_param : { file : "applySQLPatch.sql" , folder : "patch_sql" , task_action : "Apply Patch" , params : "psu" }
      when: patch.type == "PSU"
    
    # Apply patch changes on DB (if BP)
    - include: run_sql.yml
      vars:
        sql_param : { file : "applySQLPatch.sql" , folder : "patch_sql" , task_action : "Apply Patch" , params : "exa" }
      when: patch.type == "BP"

    # Apply patch changes on DB (if CPU)
    - include: run_sql.yml
      vars:
        sql_param : { file : "applySQLPatch.sql" , folder : "patch_sql" , task_action : "Apply Patch" , params : "cpu" }
      when: patch.type == "CPU"

    # When the SQL Patch is for OJVM
    - block:
    
      - name: Find the location of DB Home from the SID
        shell: 'ls -1 {{ unzip_patch_folder }}/files/sqlpatch'
        register: sqlpatchidout
    
      - set_fact:
          sqlpatchid: "{{ sqlpatchidout.stdout }}"
    
      - name: SQL Patch ID
        debug: msg="{{ sqlpatchid }}"
    
      # Apply patch changes on DB
      - include: run_sql.yml
        vars:
          sql_param : { file : "applySQLPatchOJVM.sql" , folder : "patch_sql" , task_action : "Apply Patch" , params : "{{ sqlpatchid }}" }
    
      when: patch.type == "OJVM"
    
    # Stop the database
    - include: run_sql.yml
      vars:
        sql_param : { file : "shutdown.sql" , folder : "patch_sql" , task_action : "Stop Database to re-enable DB Vault" }
      when: dbvault_enabled

    - name: Enable Database Vault
      shell: |
           {{ dbhome_locl }}/bin/chopt enable dv
      environment:
        ORACLE_HOME: "{{ dbhome_locl }}"
        ORACLE_SID: "{{ mysid }}"
      become: true
      become_user: oracle
      delegate_to: "{{ vm_ip_address }}"
      when: dbvault_enabled

    when: perform_patch_actions

  # If apply method is UNTAR
  - block:

    # Stop the database
    - include: run_sql.yml
      vars:
        sql_param : { file : "shutdown.sql" , folder : "patch_sql" , task_action : "Stop Database for OPatch" }
      when: not oci_mode or patch.dep_type is defined
      # When patch has a dependency, if the dependency is loaded running the full patch process instead of loading from lvm, the DB will be left online.

    ## TAR ##

    - name: UNTAR full Oracle
      shell: |
          rm -rf /u01/*
          tar -xzf {{ patch.apply_file }}
      args:
        chdir: "/"
      register: tmp_shell_output
      become: true
      become_user: root
      delegate_to: "{{ vm_ip_address }}"

    # Put the value inside another variable to avoid it from getting replaced with "skip_reason": "Conditional result was False"
    - set_fact: shell_output="{{tmp_shell_output}}"
      when: tmp_shell_output is not skipped

    - name: TAR Output
      debug: msg="{{ shell_output.stdout_lines }}"
      when: shell_output.stdout_lines is defined

    when: patch.apply_method is defined and patch.apply_method == "tar"

  # This start is only required if database was never stopped.
  - include: run_sql.yml
    vars:
      sql_param : { file : "startup.sql" , folder : "patch_sql" , task_action : "Start Database" }
    when: not perform_patch_actions or (perform_patch_actions and dbvault_enabled)

  # When only_deploy_patch is false (most common case)
  - block:

    # User custom pre-scripts
    - name: Run user custom pre-scripts
      include: run_script.yml
      loop: "{{ user_expdp_pre | flatten(levels=1) }}"
      loop_control:
        loop_var: script_param

    - name: Export Database Tables
      shell: |
          {{ dbhome_locl }}/bin/expdp \
          userid={{ dump_user_int }}/{{ dump_pass }} \
          directory={{ dump_dir_name }} \
          compression=all \
          dumpfile={{ dump_file_prefix }}.dmp \
          logfile={{ dump_file_prefix }}.log \
          content=data_only \
          schemas={{ dump_user_int }}
      environment:
        ORACLE_HOME: "{{ dbhome_locl }}"
        ORACLE_SID: "{{ mysid }}"
      become: true
      become_user: oracle
      delegate_to: "{{ vm_ip_address }}"

    # User custom post-scripts
    - name: Run user custom post-scripts
      include: run_script.yml
      loop: "{{ user_expdp_post | flatten(levels=1) }}"
      loop_control:
        loop_var: script_param

    when: not only_deploy_patch

  # Post Actions
  - include: patch_tasks_post.yml

  when: skip_all == false
# Skip all is true when dump file is already generated and skip_dump_exists is true at config.