# Pre Actions
- include: patch_tasks_pre.yml

- block:

  # If needs to perform patch actions
  - block:

    # Stop the database
    - include: run_sql.yml
      vars:
        sql_param : { file : "shutdown.sql" , folder : "patch_sql" , task_action : "Stop Database for OPatch" }
      when: not oci_mode or patch.dep_type is defined
      # When patch has a dependency, if the dependency is loaded running the full patch process instead of loading from lvm, the DB will be left online.

    ## APPLY ##

    - name: Run OPatch
      shell: |
          set -eo pipefail
          export ORACLE_HOME ORACLE_SID
          [ ! -d ~/opatch_logs ] && mkdir ~/opatch_logs
          ./opatch apply -silent {{ VM_folder }}/{{ patch.patch_number }} -ocmrf {{ VM_folder }}/ocm.rsp 2>&1 | tee ~/opatch_logs/{{ patch.patch_number }}.log
      environment:
        ORACLE_HOME: "{{ dbhome_locl }}"
        ORACLE_SID: "{{ mysid }}"
      args:
        chdir: "{{ dbhome_locl }}/OPatch"
      register: tmp_shell_output
      become: true
      become_user: oracle
      when: patch.apply_method is not defined or patch.apply_method == "opatch"
      delegate_to: "{{ vm_ip_address }}"

    # Put the value inside another variable to avoid it from getting replaced with "skip_reason": "Conditional result was False"
    - set_fact: shell_output="{{tmp_shell_output}}"
      when: tmp_shell_output is not skipped

    ## NAPPLY ##

    - name: Run OPatch/opatch NAPPLY
      shell: |
          set -eo pipefail
          export ORACLE_HOME ORACLE_SID
          [ ! -d ~/opatch_logs ] && mkdir ~/opatch_logs
          ./opatch napply -silent {{ VM_folder }}/{{ patch.patch_number }} -ocmrf {{ VM_folder }}/ocm.rsp 2>&1 | tee ~/opatch_logs/{{ patch.patch_number }}.log
      environment:
        ORACLE_HOME: "{{ dbhome_locl }}"
        ORACLE_SID: "{{ mysid }}"
      args:
        chdir: "{{ dbhome_locl }}/OPatch"
      register: tmp_shell_output
      become: true
      become_user: oracle
      when: patch.apply_method is defined and patch.apply_method == "napply"
      delegate_to: "{{ vm_ip_address }}"

    # Put the value inside another variable to avoid it from getting replaced with "skip_reason": "Conditional result was False"
    - set_fact: shell_output="{{tmp_shell_output}}"
      when: tmp_shell_output is not skipped

    - name: Opatch Output
      debug: msg="{{ shell_output.stdout_lines }}"
      when: shell_output.stdout_lines is defined

    - name: Disable Database Vault
      shell: |
          set -eo pipefail
           {{ dbhome_locl }}/bin/chopt disable dv
      environment:
        ORACLE_HOME: "{{ dbhome_locl }}"
        ORACLE_SID: "{{ mysid }}"
      become: true
      become_user: oracle
      delegate_to: "{{ vm_ip_address }}"
      when: dbvault_enabled
    
    # Start the database
    - include: run_sql.yml
      vars:
        sql_param : { file : "startup.sql" , folder : "patch_sql" , task_action : "Start Database for sqlpatch" }
    
    # Apply patch changes on DB (if PSU)
    - include: run_sql.yml
      vars:
        sql_param : { file : "catbundle.sql" , folder : "rdbms/admin" , task_action : "Apply PSU Patch" , params : "psu apply" , root_dir : "{{ dbhome_locl }}"}
      when: patch.type == "PSU" and patch.cat_script is not defined
    
    # Apply patch changes on DB (if BP)
    - include: run_sql.yml
      vars:
        sql_param : { file : "catbundle.sql" , folder : "rdbms/admin" , task_action : "Apply BP Patch" , params : "exa apply" , root_dir : "{{ dbhome_locl }}"}
      when: patch.type == "BP" and patch.cat_script is not defined

    # Apply patch changes on DB (if CPU)
    - include: run_sql.yml
      vars:
        sql_param : { file : "catbundle.sql" , folder : "rdbms/admin" , task_action : "Apply CPU Patch" , params : "cpu apply" , root_dir : "{{ dbhome_locl }}"}
      when: patch.type == "CPU" and patch.cat_script is not defined

    # Apply patch changes on DB (if Custom)
    - include: run_sql.yml
      vars:
        sql_param : { file : "{{ patch.cat_script | basename }}" , folder : "{{ patch.cat_script | dirname }}" , task_action : "Run: {{ patch.cat_script }}" , root_dir : "{{ dbhome_locl }}" }
      when: patch.cat_script is defined

    # When the SQL Patch is for OJVM
    - block:
    
      - name: Find the location of DB Home from the SID
        shell: 'ls -1 {{ unzip_patch_folder }}/files/sqlpatch'
        register: sqlpatchidout
    
      - set_fact:
          sqlpatchid: "{{ sqlpatchidout.stdout }}"
    
      - name: SQL Patch ID
        debug: msg="{{ sqlpatchid }}"
    
      # Apply patch changes on DB
      - include: run_sql.yml
        vars:
          sql_param : { file : "applySQLPatchOJVM.sql" , folder : "patch_sql" , task_action : "Apply Patch" , params : "{{ sqlpatchid }}" }
    
      when: patch.type == "OJVM"
    
    # Stop the database
    - include: run_sql.yml
      vars:
        sql_param : { file : "shutdown.sql" , folder : "patch_sql" , task_action : "Stop Database to re-enable DB Vault" }
      when: dbvault_enabled

    - name: Enable Database Vault
      shell: |
           {{ dbhome_locl }}/bin/chopt enable dv
      environment:
        ORACLE_HOME: "{{ dbhome_locl }}"
        ORACLE_SID: "{{ mysid }}"
      become: true
      become_user: oracle
      delegate_to: "{{ vm_ip_address }}"
      when: dbvault_enabled

    when: perform_patch_actions

  # This start is only required if database was never stopped.
  - include: run_sql.yml
    vars:
      sql_param : { file : "startup.sql" , folder : "patch_sql" , task_action : "Start Database" }
    when: not perform_patch_actions or (perform_patch_actions and dbvault_enabled)

  # When only_deploy_patch is false (most common case)
  - block:

    # User custom pre-scripts
    - name: Run user custom pre-scripts
      include: run_script.yml
      loop: "{{ user_expdp_pre | flatten(levels=1) }}"
      loop_control:
        loop_var: script_param

    - name: Remove compression parameter from expdp
      set_fact:
        expdp_compression: ""
      when: (db_version.split('.')[0] | int) <= 10

    - name: Set compression parameter for expdp
      set_fact:
        expdp_compression: "compression=all"
      when: (db_version.split('.')[0] | int) >= 11

    - name: Export Database Tables
      shell: |
          {{ dbhome_locl }}/bin/expdp \
          userid={{ dump_user_int }}/{{ dump_pass }} \
          directory={{ dump_dir_name }} \
          {{ expdp_compression | default('') }} \
          dumpfile={{ dump_file_prefix }}.dmp \
          logfile={{ dump_file_prefix }}.log \
          content=data_only \
          schemas={{ dump_user_int }}
      environment:
        ORACLE_HOME: "{{ dbhome_locl }}"
        ORACLE_SID: "{{ mysid }}"
      become: true
      become_user: oracle
      delegate_to: "{{ vm_ip_address }}"

    # User custom post-scripts
    - name: Run user custom post-scripts
      include: run_script.yml
      loop: "{{ user_expdp_post | flatten(levels=1) }}"
      loop_control:
        loop_var: script_param

    when: not only_deploy_patch

  # Post Actions
  - include: patch_tasks_post.yml

  when: skip_all == false
# Skip all is true when dump file is already generated and skip_dump_exists is true at config.